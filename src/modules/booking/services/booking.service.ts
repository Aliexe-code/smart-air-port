import {
  Injectable,
  ConflictException,
  NotFoundException,
  HttpException,
  HttpStatus,
  Inject,
  Logger,
  OnModuleInit,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import {
  IBookingRepository,
  BOOKING_REPOSITORY,
} from '../repositories/booking.repository.interface';
import { CreateBookingDto } from '../dto/create-booking.dto';
import { CreateBookingInput } from '../dto/create-booking.input';
import { FlightService } from '../../flight/flight.service';
import { PaymentService } from './payment.service';
import { UserDocument } from '../../users/schemas/user.schema';
import { BookingDocument } from '../schemas/booking.schema';
import { PaymentIntent } from '../types/booking.types';
import { EventBus } from 'src/common/event-bus.service';
import { Types, Connection } from 'mongoose';
import { InjectConnection } from '@nestjs/mongoose';
import { QueryBookingDto } from '../dto/query-booking.dto';
import { PaginatedResult } from 'src/common/interfaces/paginated-result.interface';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

function isDuplicateKeyError(error: unknown): error is { code: number } {
  if (typeof error !== 'object' || error === null) return false;
  const err = error as { code?: unknown };
  return typeof err.code === 'number';
}

@Injectable()
export class BookingService implements OnModuleInit {
  private readonly logger = new Logger(BookingService.name);

  constructor(
    @Inject(BOOKING_REPOSITORY)
    private readonly bookingRepository: IBookingRepository,
    private readonly flightService: FlightService,
    private readonly paymentService: PaymentService,
    private readonly eventBus: EventBus,
    @InjectConnection() private readonly connection: Connection,
    @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,
  ) {}

  onModuleInit(): void {
    this.eventBus.subscribe(
      'payment.succeeded',
      (data: { paymentIntentId: string }) => {
        this.confirmBookingByPayment(data.paymentIntentId).catch((error) => {
          this.logger.error(
            `Failed to confirm booking: ${
              error instanceof Error ? error.message : String(error)
            }`,
          );
        });
      },
    );

    this.eventBus.subscribe(
      'payment.failed',
      (data: { paymentIntentId: string; reason: string }) => {
        this.failBooking(data.paymentIntentId, data.reason).catch((error) => {
          this.logger.error(
            `Failed to mark booking as failed: ${
              error instanceof Error ? error.message : String(error)
            }`,
          );
        });
      },
    );
  }

  /**
 * Creates a new booking and ensures bookingRef is auto-generated by schema pre-validate hook.
 * TODO: Add audit logging for booking creation (who/when/what)
 */
  async createBooking(
    user: UserDocument,
    createBookingDto: CreateBookingDto,
    idempotencyKey: string,
  ): Promise<BookingDocument> {
    if (!Types.ObjectId.isValid(createBookingDto.flightId)) {
      throw new BadRequestException('Invalid flight ID format');
    }

    const flight = await this.flightService.findOne(createBookingDto.flightId);
    if (!flight) {
      throw new NotFoundException(
        `Flight not found. Please refresh your search results. ` +
        `If this persists, contact support with flight ID: ${createBookingDto.flightId}`
      );
    }

    const session = await this.connection.startSession();
    session.startTransaction();
    const currentVersion = flight.version; // Save current version for rollback

    try {
      // Add seat availability check
      const availableSeats = await this.flightService.getAvailableSeats(createBookingDto.flightId);
      if (createBookingDto.seats.length > availableSeats) {
        throw new BadRequestException('Not enough seats available');
      }

      // Check idempotency
      const preExisting = await this.bookingRepository.findOne({
        idempotencyKey,
      });
      if (preExisting) {
        throw new ConflictException(
          'Idempotency key already exists. Please use a unique key.',
        );
      }

      // Re-fetch flight and validate price per seat
      const flightAfterCheck = await this.flightService.findOne(
        createBookingDto.flightId,
      );

      createBookingDto.seats.forEach((seat) => {
        if (seat.price !== flightAfterCheck.price) {
          throw new BadRequestException(
            `Seat ${seat.seatNumber} price must match flight price of ${flightAfterCheck.price}`,
          );
        }
      });

      // Update flight seats using optimistic locking
      const flight = await this.flightService.findOneAndUpdate(
        { 
          _id: createBookingDto.flightId,
          version: currentVersion 
        },
        { 
          $inc: { 
            seatsAvailable: -createBookingDto.seats.length,
            version: 1 
          } 
        },
        { new: true }
      );

      if (!flight) {
        throw new ConflictException(
          'Flight was modified by another operation. Please refresh and try again.'
        );
      }

      const totalPrice = createBookingDto.seats.reduce(
        (sum, seat) => sum + seat.price,
        0,
      );

      const paymentIntent = await this.paymentService.createPaymentIntent(
        totalPrice,
        flight.currency || 'USD',
        { 
          bookingId: null,
          userId: user._id.toString()
        }
      ).catch(err => {
        this.logger.error(`Payment processing failed: ${err.message}`);
        throw new BadRequestException('Payment processing failed');
      });

      const bookingData: CreateBookingInput = {
        ...createBookingDto,
        user: user._id,
        flight: new Types.ObjectId(createBookingDto.flightId),
        status: 'pending',
        totalPrice,
        totalSeats: createBookingDto.seats.length,
        expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes expiry
        paymentIntentId: paymentIntent.id,
        idempotencyKey,
      };

      let booking: BookingDocument;
      try {
        booking = await this.bookingRepository.create(bookingData);
      } catch (error: unknown) {
        if (isDuplicateKeyError(error) && error.code === 11000) {
          throw new ConflictException(
            'Idempotency key already exists. Please use a unique key.',
          );
        }
        throw error;
      }

      this.logger.log({
        event: 'booking_created',
        bookingId: String(booking.id),
        userId: user._id.toString(),
        seats: booking.totalSeats,
      });

      await session.commitTransaction();
      return booking;
    } catch (error: unknown) {
      await session.abortTransaction();
      // Attempt seat rollback if needed
      if (createBookingDto?.seats) {
        await this.flightService
          .updateSeats({
            flightId: createBookingDto.flightId,
            seatDelta: createBookingDto.seats.length,
            expectedVersion: currentVersion,
          })
          .catch((rollbackError) => {
            this.logger.error('Seat rollback failed', rollbackError);
          });
      }
      if (error instanceof Error) throw error;
      throw new HttpException(
        'Booking creation failed',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    } finally {
      await session.endSession();
    }
  }

  /**
 * Confirms a booking and updates status. TODO: Audit log this action (who/when/what)
 */
  public async confirmBooking(
    bookingId: string,
    userId: string,
  ): Promise<BookingDocument> {
    const booking = await this.bookingRepository.findById(bookingId);
    if (!booking || booking.user.toString() !== userId) {
      throw new NotFoundException('Booking not found');
    }
    if (!booking.paymentIntentId) {
      throw new NotFoundException('Payment intent not found for booking');
    }
    await this.paymentService.confirmPayment(
      booking.paymentIntentId,
      booking.totalPrice,
    );
    return this.bookingRepository.update(
      { _id: bookingId },
      { status: 'confirmed' },
    );
  }

  /**
 * Confirms a booking via payment. TODO: Audit log this action (who/when/what)
 */
  public async confirmBookingByPayment(
    paymentIntentId: string,
  ): Promise<BookingDocument> {
    const booking = await this.bookingRepository.findOne({ paymentIntentId });
    if (!booking) {
      throw new NotFoundException(
        `Booking not found for payment intent: ${paymentIntentId}`,
      );
    }

    if (booking.status !== 'pending') {
      this.logger.warn(
        `Booking ${booking.id} is not pending (current status: ${booking.status}). Skipping confirmation.`,
      );
      return booking;
    }

    const updatedBooking = await this.bookingRepository.update(
      { _id: booking.id },
      { status: 'confirmed' },
    );
    this.logger.log(`Booking confirmed via payment: ${updatedBooking.id}`);
    return updatedBooking;
  }

  async getStatus(bookingId: string): Promise<string> {
    const booking = await this.bookingRepository.findById(bookingId);
    if (!booking) {
      throw new NotFoundException('Booking not found');
    }
    return booking.status;
  }

  async failBooking(
    paymentIntentId: string,
    reason: string,
  ): Promise<BookingDocument> {
    const booking = await this.bookingRepository.findOne({ paymentIntentId });
    if (!booking) {
      throw new NotFoundException(
        `Booking not found for payment intent: ${paymentIntentId}`,
      );
    }
    const updatedBooking = await this.bookingRepository.update(
      { _id: booking.id },
      { status: 'failed', failureReason: reason },
    );
    this.logger.warn(
      `Booking marked as failed via payment: ${updatedBooking.id}, Reason: ${reason}`,
    );
    return updatedBooking;
  }

  async findExpiredPendingBookings(): Promise<BookingDocument[]> {
    return this.bookingRepository.find({
      status: 'pending',
      expiresAt: { $lte: new Date() },
    });
  }
  
  /**
   * Find bookings with pagination and filtering
   */
  async findBookings(queryDto: QueryBookingDto): Promise<PaginatedResult<BookingDocument>> {
    const startTime = Date.now();
    const cacheKey = `bookings:${JSON.stringify(queryDto)}`;
    
    try {
      // Try to get data from cache first
      const cachedData = await this.cacheManager.get<PaginatedResult<BookingDocument>>(cacheKey);
      if (cachedData) {
        this.logger.log(`Bookings fetched from cache with key: ${cacheKey}`);
        return cachedData;
      }

      // Execute DB query if no cache hit
      const result = await this.bookingRepository.findWithPagination(queryDto);
      
      // Store in cache for 5 minutes
      await this.cacheManager.set(cacheKey, result, 5 * 60 * 1000);
      
      this.logger.debug(`Finding bookings took ${Date.now() - startTime}ms`);
      return result;
    } catch (error) {
      this.logger.error(`Error finding bookings: ${error.message}`);
      throw new InternalServerErrorException('Failed to retrieve bookings');
    }
  }
  
  /**
   * Clean up all bookings with a specific status (admin function)
   */
  async cleanupBookingsByStatus(status: string): Promise<number> {
    const startTime = Date.now();
    
    try {
      // Use MongoDB's bulkWrite for efficiency
      const session = await this.connection.startSession();
      session.startTransaction();
      
      try {
        // Find IDs of bookings to delete
        const bookingsToCleanup = await this.bookingRepository.find({ status }, { _id: 1 });
        const bookingIds = bookingsToCleanup.map(booking => booking._id);
        
        if (bookingIds.length === 0) {
          this.logger.log(`No bookings with status '${status}' found to clean up`);
          return 0;
        }
        
        // For bookings that were holding seats, release the seats back to flights
        if (status === 'pending' || status === 'failed') {
          // Get the bookings with more details to update flight seat counts
          const detailedBookings = await this.bookingRepository.find(
            { _id: { $in: bookingIds } },
            { flight: 1, totalSeats: 1 }
          );
          
          // Process each booking to release seats
          for (const booking of detailedBookings) {
            try {
              const flight = await this.flightService.findOne(booking.flight.toString());
              await this.flightService.updateSeats({
                flightId: booking.flight.toString(),
                seatDelta: booking.totalSeats, // Add seats back
                expectedVersion: flight.version,
              });
            } catch (err) {
              this.logger.error(`Failed to release seats for booking ${booking._id}: ${err.message}`);
            }
          }
        }
        
        // Delete the bookings
        let deletedCount = 0;
        for (const id of bookingIds) {
          const deleted = await this.bookingRepository.delete(id.toString());
          if (deleted) deletedCount++;
        }
        
        await session.commitTransaction();
        this.logger.log(`Successfully cleaned up ${deletedCount} bookings with status '${status}'`);
        return deletedCount;
      } catch (error) {
        await session.abortTransaction();
        throw error;
      } finally {
        session.endSession();
      }
    } catch (error) {
      this.logger.error(`Error cleaning up bookings: ${error.message}`);
      throw new InternalServerErrorException(`Failed to clean up bookings with status: ${status}`);
    } finally {
      this.logger.debug(`Cleaning up bookings took ${Date.now() - startTime}ms`);
    }
  }

  async retryPayment(bookingId: string): Promise<BookingDocument> {
    const booking = await this.bookingRepository.findById(bookingId);
    if (!booking) {
      throw new NotFoundException('Booking not found');
    }
    if (booking.status !== 'failed') {
      throw new ConflictException(
        'Payment retry is allowed only for failed bookings',
      );
    }
    const flight = await this.flightService.findOne(booking.flight.toString());
    if (!flight) {
      throw new NotFoundException('Associated flight not found');
    }
    const newPaymentIntent = await this.paymentService.createPaymentIntent({
      amount: booking.totalPrice,
      currency: 'USD',
      paymentMethod: booking.paymentProvider,
      metadata: {
        userId: booking.user.toString(),
        flightId: String(flight._id),
      },
    });
    const updatedBooking = await this.bookingRepository.update(
      { _id: booking.id },
      { paymentIntentId: newPaymentIntent.id, status: 'pending' },
    );
    this.logger.log(
      `Payment retried for booking ${booking.id}. New Payment Intent: ${newPaymentIntent.id}`,
    );
    return updatedBooking;
  }

  /**
 * Cancels a booking and releases seats. TODO: Audit log this action (who/when/what)
 */
  async cancelBooking(
    bookingId: string,
    userId: string,
  ): Promise<BookingDocument> {
    const booking = await this.bookingRepository.findById(bookingId);
    if (!booking || booking.user.toString() !== userId) {
      throw new NotFoundException('Booking not found');
    }
    if (
      booking.status === 'confirmed' ||
      (booking.status === 'pending' &&
        booking.expiresAt &&
        booking.expiresAt <= new Date())
    ) {
      if (booking.paymentIntentId) {
        try {
          await this.paymentService.processRefund(booking.paymentIntentId);
        } catch (error: unknown) {
          const errorMessage =
            error instanceof Error ? error.message : 'Unknown error';
          this.logger.error(`Refund attempt failed: ${errorMessage}`);
        }
      }
      const flight = await this.flightService.findOne(
        booking.flight.toString(),
      );
      await this.flightService.updateSeats({
        flightId: booking.flight.toString(),
        seatDelta: booking.totalSeats,
        expectedVersion: flight.version,
      });
      return this.bookingRepository.update(
        { _id: bookingId },
        {
          status: 'cancelled',
          cancellationReason:
            booking.status === 'pending' ? 'Expired' : 'User requested',
        },
      );
    }
    throw new ConflictException('Booking cannot be cancelled');
  }
}
