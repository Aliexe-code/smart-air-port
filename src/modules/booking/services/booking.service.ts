import {
  Injectable,
  ConflictException,
  NotFoundException,
  HttpException,
  HttpStatus,
  Inject,
  Logger,
  OnModuleInit,
  BadRequestException,
  InternalServerErrorException,
} from '@nestjs/common';
import {
  IBookingRepository,
  BOOKING_REPOSITORY,
} from '../repositories/booking.repository.interface';
import { CreateBookingDto } from '../dto/create-booking.dto';
import { CreateBookingInput } from '../dto/create-booking.input';
import { FlightService } from '../../flight/flight.service';
import { PaymentService } from './payment.service';
import { UserDocument } from '../../users/schemas/user.schema';
import { BookingDocument } from '../schemas/booking.schema';
import { Booking } from '../schemas/booking.schema';
import { PaymentIntent } from '../types/booking.types';
import { EventBus } from 'src/common/event-bus.service';
import { Types, Connection } from 'mongoose';
import { InjectConnection } from '@nestjs/mongoose';
import { QueryBookingDto } from '../dto/query-booking.dto';
import { PaginatedResult } from 'src/common/interfaces/paginated-result.interface';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';
import { BaggageSelectionDto, BaggageFeeResult } from '../../../shared/dtos/baggage.dto';

function isDuplicateKeyError(error: unknown): error is { code: number } {
  if (typeof error !== 'object' || error === null) return false;
  const err = error as { code?: unknown };
  return typeof err.code === 'number';
}

@Injectable()
export class BookingService implements OnModuleInit {
  private readonly logger = new Logger(BookingService.name);

  constructor(
    @Inject(BOOKING_REPOSITORY)
    private readonly bookingRepository: IBookingRepository,
    private readonly flightService: FlightService,
    private readonly paymentService: PaymentService,
    private readonly eventBus: EventBus,
    @InjectConnection() private readonly connection: Connection,
    @Inject(CACHE_MANAGER) private readonly cacheManager: Cache,
  ) {}

  onModuleInit(): void {
    this.eventBus.subscribe(
      'payment.succeeded',
      (data: { paymentIntentId: string }) => {
        this.confirmBookingByPayment(data.paymentIntentId).catch((error) => {
          this.logger.error(
            `Failed to confirm booking: ${
              error instanceof Error ? error.message : String(error)
            }`,
          );
        });
      },
    );

    this.eventBus.subscribe(
      'payment.failed',
      (data: { paymentIntentId: string; reason: string }) => {
        this.failBooking(data.paymentIntentId, data.reason).catch((error) => {
          this.logger.error(
            `Failed to mark booking as failed: ${
              error instanceof Error ? error.message : String(error)
            }`,
          );
        });
      },
    );
  }

  /**
 * Creates a new booking and ensures bookingRef is auto-generated by schema pre-validate hook.
 * TODO: Add audit logging for booking creation (who/when/what)
 */
  async createBooking(
    user: UserDocument,
    createBookingDto: CreateBookingDto,
    idempotencyKey: string,
  ): Promise<BookingDocument> {
    if (!Types.ObjectId.isValid(createBookingDto.flightId)) {
      throw new BadRequestException('Invalid flight ID format');
    }

    const flight = await this.flightService.findOne(createBookingDto.flightId);
    if (!flight) {
      throw new NotFoundException(
        `Flight not found. Please refresh your search results. ` +
        `If this persists, contact support with flight ID: ${createBookingDto.flightId}`
      );
    }

    const session = await this.connection.startSession();
    session.startTransaction();
    const currentVersion = flight.version; // Save current version for rollback

    try {
      // Add seat availability check
      const availableSeats = await this.flightService.getAvailableSeats(createBookingDto.flightId);
      if (createBookingDto.seats.length > availableSeats) {
        throw new BadRequestException('Not enough seats available');
      }

      // Check idempotency
      const preExisting = await this.bookingRepository.findOne({
        idempotencyKey,
      });
      if (preExisting) {
        throw new ConflictException(
          'Idempotency key already exists. Please use a unique key.',
        );
      }

      // Re-fetch flight and validate price per seat
      const flightAfterCheck = await this.flightService.findOne(
        createBookingDto.flightId,
      );

      createBookingDto.seats.forEach((seat) => {
        if (seat.price !== flightAfterCheck.price) {
          throw new BadRequestException(
            `Seat ${seat.seatNumber} price must match flight price of ${flightAfterCheck.price}`,
          );
        }
      });

      // Validate baggage options
      if (createBookingDto.baggageOptions?.length) {
        const isValid = await this.flightService.validateBaggage(
          createBookingDto.flightId, 
          createBookingDto.baggageOptions
        );
        
        if (!isValid) {
          throw new Error('Invalid baggage selection');
        }
      }

      // Update flight seats using optimistic locking
      const flight = await this.flightService.findOneAndUpdate(
        { 
          _id: createBookingDto.flightId,
          version: currentVersion 
        },
        { 
          $inc: { 
            seatsAvailable: -createBookingDto.seats.length,
            version: 1 
          } 
        },
        { new: true }
      );

      if (!flight) {
        throw new ConflictException(
          'Flight was modified by another operation. Please refresh and try again.'
        );
      }

      let totalPrice = 0;
      totalPrice = createBookingDto.seats.reduce(
        (sum, seat) => sum + seat.price,
        0,
      );

      const baggageFees = this.calculateBaggageFees(createBookingDto, flight);
      totalPrice += baggageFees.total;

      const paymentIntent = await this.paymentService.createPaymentIntent(
        totalPrice,
        flight.currency || 'USD',
        { 
          bookingId: null,
          userId: user._id.toString()
        }
      ).catch(err => {
        this.logger.error(`Payment processing failed: ${err.message}`);
        throw new BadRequestException('Payment processing failed');
      });

      const bookingData: CreateBookingInput = {
        ...createBookingDto,
        user: user._id,
        flight: new Types.ObjectId(createBookingDto.flightId),
        status: 'pending',
        totalPrice,
        totalSeats: createBookingDto.seats.length,
        expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30 minutes expiry
        paymentIntentId: paymentIntent.id,
        idempotencyKey,
        baggageFees: baggageFees.total,
        baggageBreakdown: baggageFees.breakdown,
      };

      let booking: BookingDocument;
      try {
        booking = await this.bookingRepository.create(bookingData);
      } catch (error: unknown) {
        if (isDuplicateKeyError(error) && error.code === 11000) {
          throw new ConflictException(
            'Idempotency key already exists. Please use a unique key.',
          );
        }
        throw error;
      }

      this.logger.log({
        event: 'booking_created',
        bookingId: String(booking.id),
        userId: user._id.toString(),
        seats: booking.totalSeats,
      });

      await session.commitTransaction();
      return booking;
    } catch (error: unknown) {
      await session.abortTransaction();
      // Attempt seat rollback if needed
      if (createBookingDto?.seats) {
        await this.flightService
          .updateSeats({
            flightId: createBookingDto.flightId,
            seatDelta: createBookingDto.seats.length,
            expectedVersion: currentVersion,
          })
          .catch((rollbackError) => {
            this.logger.error('Seat rollback failed', rollbackError);
          });
      }
      if (error instanceof Error) throw error;
      throw new HttpException(
        'Booking creation failed',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    } finally {
      await session.endSession();
    }
  }

  async confirmBookingByPayment(paymentIntentId: string): Promise<BookingDocument> {
    const booking = await this.bookingRepository.findOne({ paymentIntentId });
    if (!booking) throw new NotFoundException('Booking not found');
    
    return this.bookingRepository.update(
      { _id: booking.id },
      { status: 'confirmed' }
    );
  }

  async failBooking(paymentIntentId: string, reason: string): Promise<BookingDocument> {
    const booking = await this.bookingRepository.findOne({ paymentIntentId });
    if (!booking) throw new NotFoundException('Booking not found');
    
    return this.bookingRepository.update(
      { _id: booking.id },
      { status: 'failed', failureReason: reason }
    );
  }

  async findExpiredPendingBookings(expiryMinutes: number = 15): Promise<Booking[]> {
    const expiryTime = new Date(Date.now() - expiryMinutes * 60 * 1000);
    return this.bookingRepository.find({
      where: {
        status: 'pending',
        createdAt: { $lt: expiryTime }
      }
    });
  }

  private calculateBaggageFees(
    dto: CreateBookingDto,
    flight: any
  ): BaggageFeeResult {
    let feeTotal = 0;
    
    const breakdown = dto.baggageOptions?.map(option => {
      const baggageType = (flight.baggageOptions as any[]).find(
        b => b.type === option.type
      );
      const unitPrice = Number(baggageType?.price || 0);
      const subtotal = unitPrice * option.quantity;
      feeTotal += subtotal;
      
      return { ...option, unitPrice, subtotal };
    }) || [];
    
    return { total: feeTotal, breakdown };
  }

  // ... rest of the code remains the same ...
}
